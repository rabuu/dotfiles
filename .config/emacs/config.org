#+title: My Emacs Configuration
#+author: Rasmus Buurman (@rabuu)
#+startup: show2levels
#+babel: :cache yes

I use ~org-mode~ for this literate configuration.
This ~config.org~ file generates an [[file:early-init.el][early-init.el]] and the [[file:init.el][init.el]] file.

To (re)generate the configuration use ~M-x org-babel-tangle~ or ~C-c C-v C-t~.

* early-init.el
:properties:
:header-args+: :tangle "./early-init.el"
:end:

In ~early-init.el~ we handle things that should be done before loading the main ~init.el~ file.

This is the header for the ~early-init.el~ file.
#+begin_src emacs-lisp
;;; early-init.el -*- lexical-binding: t; eval: (view-mode -1) -*-

;;; Commentary:
;; This file is evaluated before init.el.
;; It is generated by config.org.

;;; Code:
#+end_src

** Native compilation cache
Change native compilation cache directory.
#+begin_src emacs-lisp
(when (fboundp 'startup-redirect-eln-cache)
  (startup-redirect-eln-cache
   (convert-standard-filename
    (expand-file-name  "var/eln-cache/" user-emacs-directory))))
#+end_src

** Speedup
*** Disable some things
#+begin_src emacs-lisp
(setq package-enable-at-startup nil  ; disable package.el
      frame-inhibit-implied-resize t ; disable frame resizing
      site-run-file nil              ; disable site-run-file
      inhibit-compacting-font-caches t) ; don't compact font caches
#+end_src

*** Disable default UI elements
I don't like some of the default Emacs UI elements. Let's disable them.
#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(add-to-list 'default-frame-alist '(vertical-scroll-bars . nil))
#+end_src

*** Garbage Collection
Max the GC theshold on startup. Reset it later.
#+begin_src emacs-lisp
(defvar my/gc-cons-threshold 16777216)
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.6)
(add-hook 'emacs-startup-hook
          (lambda ()
            (setq gc-cons-threshold my/gc-cons-threshold
                  gc-cons-percentage 0.1)))

(defun my/defer-garbage-collection-h ()
  (setq gc-cons-threshold most-positive-fixnum))

(defun my/restore-garbage-collection-h ()
  (run-at-time
   1 nil (lambda () (setq gc-cons-threshold my/gc-cons-threshold))))

(add-hook 'minibuffer-setup-hook #'my/defer-garbage-collection-h)
(add-hook 'minibuffer-exit-hook #'my/restore-garbage-collection-h)
(setq garbage-collection-messages t)
#+end_src

*** Temporarily disable file handling
We unset ~file-name-handler-alist~ and reset it after Emacs has finished initializing.
#+begin_src emacs-lisp
(defvar my/-file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)
(add-hook 'emacs-startup-hook
	  (lambda () (setq file-name-handler-alist my/-file-name-handler-alist)))
#+end_src

*** Improve I/O
Optimization for improving IO perf. Increase max bytes read from a sub-process in a single op.
#+begin_src emacs-lisp
(when (boundp 'read-process-output-max)
  (setq read-process-output-max (* 1024 1024)))
#+end_src

** Package Manager: straight.el
I use [[https://github.com/radian-software/straight.el][straight.el]] as package manager.

First we want to setup some settings.
#+begin_src emacs-lisp
(setq straight-use-package-by-default t
      straight-cache-autoloads t
      straight-vc-git-default-clone-depth 1
      straight-check-for-modifications '(find-when-checking)
      vc-follow-symlinks t)
#+end_src

Then we want to bootstrap/install the package manager.
#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name
	"straight/repos/straight.el/bootstrap.el"
	(or (bound-and-true-p straight-base-dir)
	    user-emacs-directory)))
      (bootstrap-version 7))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
	(url-retrieve-synchronously
	 "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
	 'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(setq vc-follow-symlinks 'ask)
#+end_src

Let's load the optional ~straight-x~ package which provides some convenience functions.
#+begin_src emacs-lisp
(require 'straight-x)
#+end_src

Now let's install the ~use-package~ macro that we will use throughout the rest of the configuration.
#+begin_src emacs-lisp
(straight-use-package 'use-package)
#+end_src

** Garbage Collector Magic Hack
~gcmh~ is a package that improves the GC.
#+begin_src emacs-lisp
(use-package gcmh
  :config (gcmh-mode 1))
#+end_src

** early-init.el footer
#+begin_src emacs-lisp
(provide 'early-init)

;;; early-init.el ends here
#+end_src

* init.el
:properties:
:header-args+: :tangle "./init.el"
:end:

The main part of the configuration goes into the ~init.el~ file.
#+begin_src emacs-lisp
;;; init.el -*- lexical-binding: t; eval: (view-mode -1) -*-

;;; Commentary:
;; The main configuration file of Emacs.
;; It is generated by config.org.

;;; Code:
#+end_src

** General configuration
*** Settings
Here we set our own default settings.
#+begin_src emacs-lisp
(setq-default
 default-directory "~/"
 initial-scratch-message ";; GNU Emacs\n;; This is the *scratch* buffer, do whatever you feel like.\n\n"
 user-full-name "Rasmus Buurman"
 user-mail-address "dev@rbuurman.de"
 inhibit-startup-screen t
 auto-save-default t
 scroll-margin 2
 enable-recursive-minibuffers t
 custom-safe-themes t
 delete-selection-mode t
 create-lockfiles nil
 backup-by-copying t
 use-short-answers t)
#+end_src

*** User Home Cleanup
[[https://github.com/emacscollective/no-littering][no-littering]] sets default paths so that our user home directory doesn't get littered.
#+begin_src emacs-lisp
(use-package no-littering
  :custom
  (auto-save-file-name-transforms
   `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
  (backup-directory-alist `(("." . ,(no-littering-expand-var-file-name "backup/")))))
#+end_src

*** Simple modes
Enable some useful standard modes.
#+begin_src emacs-lisp
;; save minibuffer history
(setq savehist-file (no-littering-expand-var-file-name "savehist"))
(savehist-mode)

;; automatically insert matching pairs like parens or quotes
(electric-pair-mode t)

;; always highlight code
(global-font-lock-mode 1)

;; refresh a buffer if changed on disk
(global-auto-revert-mode 1)
#+end_src

*** UI
**** Theme
For now, I use the Emacs builtin ~modus-operandi~ theme.
#+begin_src emacs-lisp
(load-theme 'modus-operandi t)
#+end_src

**** Line numbers
This enables line numbers in every buffer.
#+begin_src emacs-lisp
(global-display-line-numbers-mode 1)
#+end_src

**** Highlight current line
#+begin_src emacs-lisp
(use-package hl-line
  :hook
  (prog-mode . hl-line-mode)
  (text-mode . hl-line-mode))
#+end_src

*** Font
Let's define the fonts we want to use as variables.
Make sure you have the specified fonts installed on your system.
#+begin_src emacs-lisp
(defvar my/font-fixed "JetBrainsMono Nerd Font")
(defvar my/font-fixed-height 120)
(defvar my/font-variable "Cantarell")
(defvar my/font-variable-height 140)
#+end_src

Lets create a function that configures our fonts.
#+begin_src emacs-lisp
(defun my/configure-fonts ()
  (set-face-attribute 'default nil :font my/font-fixed :height my/font-fixed-height)
  (set-face-attribute 'fixed-pitch nil :font my/font-fixed :height my/font-fixed-height)
  (set-face-attribute 'variable-pitch nil :font my/font-variable :height my/font-variable-height))
#+end_src

Now we want to run our font configuration function.
If we are in ~--daemon~ mode, we want to run it every time a new frame is created.
#+begin_src emacs-lisp
(if (daemonp)
    (add-hook 'server-after-make-frame-hook #'my/configure-fonts)
  (my/configure-fonts))
#+end_src

*** Customization file
We don't want to clutter our configuration, so we define a ~custom.el~ file for customization.
#+begin_src emacs-lisp
(let ((customization-file
       (no-littering-expand-etc-file-name "custom.el")))
  (unless (file-exists-p customization-file)
    (write-region "" nil customization-file))
  (setq custom-file customization-file)
  (load custom-file 'noerror))
#+end_src

*** Utility functions

**** Reload Emacs configuration
#+begin_src emacs-lisp
(defun my/reload-emacs ()
  "Reload the Emacs configuration"
  (interactive)
  (load-file (expand-file-name "init.el" user-emacs-directory)))
#+end_src

*** Global key bindings
#+begin_src emacs-lisp
(use-package emacs
  :bind
  (("C-c r" . my/reload-emacs)
   ("<escape>" . keyboard-escape-quit)))
#+end_src

** Simple Packages
Here we install some packages that don't need to be mentioned in their own section.
*** emacs-compat
This is compatibility layer library some packages use.
#+begin_src emacs-lisp
(use-package compat)
#+end_src

*** diminish
This lets us hide certain minor modes from the modeline.
#+begin_src emacs-lisp
(use-package diminish)
#+end_src

The packages we installed in ~early-init.el~ couldn't be declared with ~:deminish~. So let's do it now.
#+begin_src emacs-lisp
(diminish 'gcmh-mode)
#+end_src

*** transient
This is a library used to implement keyboard-driven "menus", specifically in ~magit~.
#+begin_src emacs-lisp
(use-package transient)
#+end_src

*** All the Icons
This is a utility package for all things that have to do with icons.
Quite a few other packages make use of this.
#+begin_src emacs-lisp
(use-package all-the-icons)
#+end_src

It is very important to install the resource fonts included in this packages.
Use ~M-x all-the-icons-install-fonts~.

*** undo-tree
Emacs' default undo system is a bit weird. ~undo-tree~ provides a more vim-like undo behavior.
#+begin_src emacs-lisp
(use-package undo-tree
  :diminish
  :init (global-undo-tree-mode)
  :config
  (setq undo-tree-auto-save-history t)
  :custom
  (undo-tree-history-directory-alist `(("." . ,(no-littering-expand-var-file-name "undo-tree-hist/"))))
  :bind (("C-c u u" . undo-tree-undo)
	 ("C-c u r" . undo-tree-redo)
	 ("C-c u v" . undo-tree-visualize)))
#+end_src

*** which-key
This is a very useful package that helps you with your key bindings.
#+begin_src emacs-lisp
(use-package which-key
  :diminish
  :init (which-key-mode))
#+end_src

*** magit
[[https://magit.vc/][Magit]] is a magical git client for Emacs.
#+begin_src emacs-lisp
(use-package magit)
#+end_src

** Minibuffer UI
My minibuffer configuration uses [[https://github.com/minad/vertico][vertico]], [[https://github.com/minad/marginalia][marginalia]] and [[https://github.com/oantolin/orderless][orderless]]
which together provide a nice way of interacting with all kinds of minibuffers.

*** Vertico
This is a minibuffer interface. It changes how minibuffers in general look and how you interact.
#+begin_src emacs-lisp
(use-package vertico
  :custom
  (vertico-resize nil)
  (vertico-cycle t)
  :init (vertico-mode))
#+end_src

*** Marginalia
This provides nice minibuffer annotations.
#+begin_src emacs-lisp
(use-package marginalia
  :init (marginalia-mode))
#+end_src

*** Orderless
This provides an alternative completion style for candidate-filtering.
#+begin_src emacs-lisp
(use-package orderless
  :custom
  (completion-styles '(orderless basic))
  (completion-category-defaults nil)
  (completion-category-overrides
   '((file (styles partial-completion basic-remote orderless)))))
#+end_src

** Text completion
I use a [[https://github.com/minad/corfu][corfu]] based completion setup.

First, we want to set some completion-related general settings.
#+begin_src emacs-lisp
(setq tab-always-indent 'complete
      text-mode-ispell-word-completion nil
      read-extended-command-predicate #'command-completion-default-include-p)
#+end_src

*** corfu
~corfu~ is an in-buffer text-completion package. It provides the completion popup.
Let's install it.
#+begin_src emacs-lisp
(use-package corfu
  :init (global-corfu-mode))
#+end_src

**** kind-icon
This provides kind little icons in ~corfu~ completion popups.
#+begin_src emacs-lisp
(use-package kind-icon
  :after corfu
  :custom
  (kind-icon-use-icons t)
  (kind-icon-default-face 'corfu-default)
  (svg-lib-icons-dir (no-littering-expand-var-file-name "svg-lib/cache/"))
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src

*** TODO cape
[[https://github.com/minad/cape][cape]] provides a number of completion-at-point functions.
It can be much more powerful than how it is currently set up.
#+begin_src emacs-lisp
(use-package cape
  :bind (("C-c c p" . 'completion-at-point)
	 ("C-c c f" . 'cape-file)))
#+end_src

** TODO consult
[[https://github.com/minad/consult][consult]] offers a bunch of useful search and navigation commands.
#+begin_src emacs-lisp
(use-package consult
  :hook (completion-list-mode . consult-preview-at-point-mode))
#+end_src

** Programming
*** LSP: eglot
#+begin_src emacs-lisp
(use-package eglot
  :hook (prog-mode . eglot-ensure)
  :bind (:map eglot-mode-map
	      ("C-c l a" . eglot-code-actions)
	      ("C-c l r" . eglot-rename)
	      ("C-c l f" . eglot-format)))
#+end_src

*** Rust
For my Rust development I rely on [[https://github.com/emacs-rustic/rustic][rustic-mode]].
#+begin_src emacs-lisp
(use-package rustic
  :custom
  (rustic-format-on-save t))
#+end_src

** org-mode

For the sake of modularity, first let's define a function that configures our ~org-mode~ faces.
#+begin_src emacs-lisp
(defun my/configure-org-faces ()
  (dolist (face '((org-level-1 . 1.35)
		  (org-level-2 . 1.3)
		  (org-level-3 . 1.2)
		  (org-level-4 . 1.1)
		  (org-level-5 . 1.1)
		  (org-level-6 . 1.1)
		  (org-level-7 . 1.1)
		  (org-level-8 . 1.1)))
    (set-face-attribute (car face) nil :font my/font-variable :height (cdr face)))

  (custom-theme-set-faces
   'user
   '(org-block ((t (:inherit fixed-pitch))))
   '(org-code ((t (:inherit (shadow fixed-pitch)))))
   '(org-document-title ((t (:weight bold :height 1.7))))
   '(org-document-info ((t (:foreground "dark orange"))))
   '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
   '(org-indent ((t (:inherit (org-hide fixed-pitch)))))
   '(org-hide ((t (:inherit fixed-pitch))))
   '(line-number ((t (:inherit fixed-pitch))))
   '(org-link ((t (:foreground "royal blue" :underline t))))
   '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
   '(org-property-value ((t (:inherit fixed-pitch))) t)
   '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
   '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
   '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
   '(org-verbatim ((t (:inherit (shadow fixed-pitch)))))))
#+end_src

Now we can set up a pretty ~org-mode~.
#+begin_src emacs-lisp
(use-package org
  :hook
  (org-mode . visual-line-mode)
  (org-mode . variable-pitch-mode)
  :custom
  (org-ellipsis " >")
  (org-hide-emphasis-markers t)
  (org-adapt-indentation nil)
  (org-fontify-done-headline t)
  (org-hide-leading-stars nil)
  (org-pretty-entities t)
  (org-src-fontify-natively t)
  (org-src-tab-acts-natively t)
  (org-edit-src-content-indentation 0)
  :config
  (my/configure-org-faces)
  (diminish 'visual-line-mode)
  (diminish 'buffer-face-mode))
#+end_src

*** org-roam
~org-roam~ is a knowledge base system that provides a way for note taking in Emacs.
#+begin_src emacs-lisp
(use-package org-roam
  :init
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory "~/roam")
  (org-roam-completion-everywhere t)
  :config (org-roam-setup)
  :bind (("C-c n t" . org-roam-buffer-toggle)
	 ("C-c n f" . org-roam-node-find)
	 ("C-c n i" . org-roam-node-insert)
	 :map org-mode-map
	 ("C-M-i" . completion-at-point)))
#+end_src

** File manager: dired
We want to set some custom options for ~dired~.
#+begin_src emacs-lisp
(setq-default
 dired-kill-when-opening-new-dired-buffers t
 dired-listing-switches "-alh")
#+end_src

Here we use ~diredfl~ to make the default ~dired~ a little prettier.
#+begin_src emacs-lisp
(use-package diredfl
  :init (diredfl-global-mode))
#+end_src

** Terminal Emulator: vterm
~vterm~ is a terminal emulator for Emacs.
#+begin_src emacs-lisp
(use-package vterm
  :bind (("C-c t" . vterm-other-window)
	 ("C-c T" . vterm)))
#+end_src

** TODO Mail Client: mu4e
~mu4e~ is a mail client for Emacs. Make sure is installed on your system.
#+begin_src emacs-lisp :tangle no
(add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e/")
(require 'mu4e)
#+end_src

Now we can setup ~mu4e~ to our liking.
#+begin_src emacs-lisp :tangle no
(setq mu4e-maildir "~/.mail"
      mu4e-personal-addresses '("rasmus@rbuurman.de")
      mu4e-get-mail-command "mbsync -a"
      mu4e-change-filenames-when-moving t
      mu4e-confirm-quit nil)

(setq mu4e-contexts
      `(, (make-mu4e-context
	   :name "personal"
	   :enter-func (lambda () (mu4e-message "Entering personal context"))
	   :leave-func (lambda () (mu4e-message "Leaving personal context"))
	   :match-func (lambda (msg)
			 (when msg (string-prefix-p "/personal" (mu4e-message-field msg :maildir))))
	   :vars '((user-mail-address . "rasmus@rbuurman.de")
		   (user-full-name . "Rasmus Buurman")
		   (mu4e-drafts-folder . "/personal/Drafts")
		   (mu4e-sent-folder . "/personal/Sent")
		   (mu4e-refile-folder . "/personal/Archives")
		   (mu4e-trash-folder . "/personal/Trash")))))

(setq mu4e-maildir-shortcuts '((:maildir "/personal/Inbox" :key ?i)))
#+end_src

** init.el footer
#+begin_src emacs-lisp
(provide 'init)

;;; init.el ends here
#+end_src
